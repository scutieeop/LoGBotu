const axios = require('axios');const { WebhookClient, EmbedBuilder } = require('discord.js');const logger = require('./logger');const InMemoryStorage = require('./inMemoryStorage');const LogAlarm = require('../models/LogAlarm');let storage = null;const alarmStorage = new InMemoryStorage('logAlarms');class LogTools {  static async initialize(options = {}) {    storage = new InMemoryStorage(options);    await storage.initialize();    return storage;  }  static getStorage() {    if (!storage) {      throw new Error('LogTools henÃ¼z baÅŸlatÄ±lmadÄ±. Ã–nce initialize() Ã§aÄŸrÄ±lmalÄ±.');    }    return storage;  }  static async checkLogAlarms(logContent, level, context) {    try {      if (!storage) {        await this.initialize();      }      const matchingAlarms = storage.checkLogAlarms(logContent, level, context);      for (const alarm of matchingAlarms) {        await this.executeAlarmAction(alarm, { logContent, level, context });      }      return matchingAlarms;    } catch (error) {      logger.error(`Log alarmlarÄ± kontrol edilirken hata oluÅŸtu: ${error.message}`, 'LogTools');      return [];    }  }  static async executeAlarmAction(alarm, logData) {    try {      const { action, actionConfig } = alarm;      switch (action) {        case 'webhook':          await this.sendWebhookNotification(actionConfig.webhookUrl, {            title: `Log AlarmÄ±: ${alarm.name}`,            description: alarm.description,            content: logData.logContent,            level: logData.level,            context: logData.context,            timestamp: new Date().toISOString()          });          break;        case 'discord':          await this.sendDiscordNotification(actionConfig.webhookUrl, {            title: `Log AlarmÄ±: ${alarm.name}`,            description: alarm.description,            content: logData.logContent,            level: logData.level,            context: logData.context,            color: actionConfig.color || '#FF0000',            timestamp: new Date().toISOString()          });          break;        case 'log':          logger.warn(`Log AlarmÄ± Tetiklendi: ${alarm.name} - ${logData.logContent}`, 'LogAlarm');          break;        default:          logger.warn(`Bilinmeyen alarm aksiyonu: ${action}`, 'LogTools');      }    } catch (error) {      logger.error(`Alarm aksiyonu yÃ¼rÃ¼tÃ¼lÃ¼rken hata oluÅŸtu: ${error.message}`, 'LogTools');    }  }  static async sendDiscordNotification(webhookUrl, data) {    try {      const { title, description, content, level, context, color, timestamp } = data;      const embed = {        title,        description,        color: parseInt(color.replace('#', ''), 16),        fields: [          { name: 'Ä°Ã§erik', value: content.substring(0, 1024) },          { name: 'Seviye', value: level, inline: true },          { name: 'BaÄŸlam', value: context || 'BelirtilmemiÅŸ', inline: true }        ],        timestamp      };      const response = await fetch(webhookUrl, {        method: 'POST',        headers: { 'Content-Type': 'application/json' },        body: JSON.stringify({ embeds: [embed] })      });      if (!response.ok) {        throw new Error(`Discord webhook yanÄ±tÄ± baÅŸarÄ±sÄ±z: ${response.status}`);      }    } catch (error) {      logger.error(`Discord bildirimi gÃ¶nderilirken hata oluÅŸtu: ${error.message}`, 'LogTools');    }  }  static async sendWebhookNotification(webhookUrl, data) {    try {      const response = await fetch(webhookUrl, {        method: 'POST',        headers: { 'Content-Type': 'application/json' },        body: JSON.stringify(data)      });      if (!response.ok) {        throw new Error(`Webhook yanÄ±tÄ± baÅŸarÄ±sÄ±z: ${response.status}`);      }    } catch (error) {      logger.error(`Webhook bildirimi gÃ¶nderilirken hata oluÅŸtu: ${error.message}`, 'LogTools');    }  }  static async trackUserActivity(userId, guildId, activityData) {    try {      if (!storage) {        await this.initialize();      }      let tracker = storage.getUserTracker(userId);      if (!tracker) return false;      const { type, data } = activityData;      switch (type) {        case 'message':          return storage.trackUserMessage(userId, data);        case 'voice':          return storage.trackUserVoice(userId, data);        case 'role':          return storage.trackUserRoleChange(userId, data);      }      const tracker2 = storage.getUserTracker(userId);      if (tracker2 && tracker2.lastNotification) {        await this.sendUserTrackNotification(          tracker2,           tracker2.lastNotification        );        const updateData = { ...tracker2 };        delete updateData.lastNotification;        storage.updateUserTracker(userId, updateData);      }      return true;    } catch (error) {      logger.error(`KullanÄ±cÄ± aktivitesi izlenirken hata oluÅŸtu: ${error.message}`, 'LogTools');      return false;    }  }  static async sendUserTrackNotification(userTrack, notificationData) {    try {      if (!userTrack.notifications.channelId) return;      logger.info(`KullanÄ±cÄ± izleme bildirimi: ${userTrack.userId} - ${notificationData.type}`, 'UserTrack');    } catch (error) {      logger.error(`KullanÄ±cÄ± izleme bildirimi gÃ¶nderilirken hata oluÅŸtu: ${error.message}`, 'LogTools');    }  }  static async generateLogStats(startDate, endDate, filters = {}) {    return {      totalLogs: 0,      byLevel: {        info: 0,        warn: 0,        error: 0,        debug: 0      },      byContext: {},      mostFrequentPatterns: [],      timeDistribution: {        hourly: [],        daily: []      },      generatedAt: new Date()    };  }}async function processLogAlarms(content, level, context, guildId) {  try {    const now = new Date();    const alarms = alarmStorage.getAll().filter(alarm => {      if (!alarm.enabled || alarm.guildId !== guildId) return false;      if (alarm.level && alarm.level !== level) return false;      if (alarm.context && alarm.context !== context) return false;      if (alarm.lastTriggered && alarm.cooldownPeriod > 0) {        const elapsed = now - new Date(alarm.lastTriggered);        if (elapsed < alarm.cooldownPeriod) return false;      }      try {        const regex = new RegExp(alarm.pattern, 'i');        return regex.test(content);      } catch (error) {        console.error(`Invalid regex pattern in alarm ${alarm.id}: ${alarm.pattern}`, error);        return false;      }    });    const triggeredAlarms = [];    for (const alarm of alarms) {      const updatedAlarm = {        ...alarm,        lastTriggered: now.toISOString(),        triggeredCount: (alarm.triggeredCount || 0) + 1      };      alarmStorage.update(alarm.id, updatedAlarm);      await executeAlarmActions(updatedAlarm, {        content,        level,        context,        timestamp: now.toISOString()      });      triggeredAlarms.push(updatedAlarm);    }    return triggeredAlarms;  } catch (error) {    console.error('Error processing log alarms:', error);    return [];  }}async function executeAlarmActions(alarm, logData) {  try {    const { action, actionConfig } = alarm;    if (!action) return true;    const content = `**Log Alarm Triggered:** ${alarm.name}\n` +      `**Pattern:** \`${alarm.pattern}\`\n` +      `**Level:** ${logData.level}\n` +      `**Context:** ${logData.context}\n` +      `**Triggered:** ${logData.timestamp}\n` +      `**Content:** \`\`\`\n${logData.content}\n\`\`\``;    const embed = new EmbedBuilder()      .setColor(alarm.level === 'error' ? '#FF0000' :                 alarm.level === 'warn' ? '#FFA500' : '#00BFFF')      .setTitle(`ðŸš¨ Log Alarm: ${alarm.name}`)      .setDescription(`Pattern: \`${alarm.pattern}\``)      .addFields(        { name: 'Level', value: logData.level || 'N/A', inline: true },        { name: 'Context', value: logData.context || 'N/A', inline: true },        { name: 'Triggered', value: logData.timestamp || new Date().toISOString(), inline: true },        { name: 'Content', value: logData.content.length > 1000 ?                                logData.content.substring(0, 1000) + '...' :                                logData.content }      )      .setTimestamp();    switch (action) {      case 'discord_channel':        if (actionConfig.channelId && global.client) {          const channel = await global.client.channels.fetch(actionConfig.channelId);          if (channel) {            await channel.send({               content: actionConfig.message || null,              embeds: [embed]            });          }        }        break;      case 'discord_webhook':        if (actionConfig.webhookUrl) {          const webhook = new WebhookClient({ url: actionConfig.webhookUrl });          await webhook.send({            content: actionConfig.message || null,            embeds: [embed],            username: actionConfig.username || 'Log Alarm'          });        }        break;      case 'webhook':        if (actionConfig.webhookUrl) {          await axios.post(actionConfig.webhookUrl, {            alarm: {              id: alarm.id,              name: alarm.name,              pattern: alarm.pattern,              level: alarm.level,              context: alarm.context            },            log: logData          }, {            headers: {              'Content-Type': 'application/json',              ...(actionConfig.headers || {})            }          });        }        break;      case 'log':      default:        console.log(`[Log Alarm] ${alarm.name} triggered:`, {          pattern: alarm.pattern,          log: logData        });        break;    }    return true;  } catch (error) {    console.error('Error executing alarm actions:', error);    return false;  }}async function createLogAlarm(alarmData) {  try {    const newAlarm = {      name: alarmData.name,      description: alarmData.description || '',      level: alarmData.level || '',      context: alarmData.context || '',      pattern: alarmData.pattern,      action: alarmData.action || 'log',      actionConfig: alarmData.actionConfig || {},      enabled: alarmData.enabled !== undefined ? alarmData.enabled : true,      cooldownPeriod: alarmData.cooldownPeriod || 0,      guildId: alarmData.guildId || '0',      createdBy: alarmData.createdBy || '0',      triggeredCount: 0    };    const savedAlarm = alarmStorage.add(newAlarm);    return savedAlarm;  } catch (error) {    console.error('Error creating log alarm:', error);    throw error;  }}async function updateLogAlarm(alarmId, updateData) {  try {    const alarm = alarmStorage.get(alarmId);    if (!alarm) {      throw new Error(`Log alarm with ID ${alarmId} not found`);    }    const protectedFields = ['id', 'createdAt', 'createdBy'];    const safeUpdateData = {};    Object.keys(updateData).forEach(key => {      if (!protectedFields.includes(key)) {        safeUpdateData[key] = updateData[key];      }    });    const updatedAlarm = alarmStorage.update(alarmId, safeUpdateData);    return updatedAlarm;  } catch (error) {    console.error('Error updating log alarm:', error);    throw error;  }}async function deleteLogAlarm(alarmId) {  try {    const result = alarmStorage.remove(alarmId);    return result;  } catch (error) {    console.error('Error deleting log alarm:', error);    throw error;  }}async function getGuildLogAlarms(guildId) {  try {    const alarms = alarmStorage.find(alarm => alarm.guildId === guildId);    return alarms;  } catch (error) {    console.error('Error getting guild log alarms:', error);    throw error;  }}module.exports = {  processLogAlarms,  createLogAlarm,  updateLogAlarm,  deleteLogAlarm,  getGuildLogAlarms}; 