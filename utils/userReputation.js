const { EmbedBuilder } = require('discord.js');const InMemoryStorage = require('./inMemoryStorage');const reputationStorage = new InMemoryStorage('userReputation');const warningStorage = new InMemoryStorage('userWarnings');class UserReputation {  constructor(client) {    this.client = client;    this.enabled = true;    this.actionPoints = {      MESSAGE_CREATE: 0.1,      MESSAGE_DELETE: -0.2,      VOICE_JOIN: 0.5,      VOICE_LEAVE: 0,      INVITE_CREATE: 1,      MEMBER_JOIN: 0,      MEMBER_LEAVE: -1,      REACTION_ADD: 0.1,      EMOJI_CREATE: 0.5,      TIMEOUT_RECEIVE: -5,      BAN_RECEIVE: -50,      KICK_RECEIVE: -20,      WARN_RECEIVE: -2,      SUSPICIOUS_BEHAVIOR: -10,      COMMAND_USE: 0.2,      HELPFUL_ACTION: 5,      SERVER_BOOST: 20    };    this.thresholds = {      suspicious: -10,      warning: -25,      danger: -50,      trusted: 50,      respected: 100,      moderationHelper: 200    };    this.initialize();  }  initialize() {    console.log('User reputation system initialized');    return true;  }  getUserReputation(userId, guildId) {    const key = `${userId}-${guildId}`;    let userData = reputationStorage.get(key);    if (!userData) {      userData = {        id: key,        userId,        guildId,        score: 0,        history: [],        firstSeen: new Date().toISOString(),        lastUpdated: new Date().toISOString(),        trustLevel: 'neutral'      };      reputationStorage.add(userData);    }    return userData;  }  async updateReputation(userId, guildId, actionType, points = null, reason = null) {    if (!this.enabled) return null;    if (!userId || !guildId) return null;    const key = `${userId}-${guildId}`;    const userData = this.getUserReputation(userId, guildId);    const pointChange = points !== null ? points : (this.actionPoints[actionType] || 0);    const oldScore = userData.score;    const newScore = Math.max(-100, Math.min(500, oldScore + pointChange));    const oldTrustLevel = this.getTrustLevel(oldScore);    const newTrustLevel = this.getTrustLevel(newScore);    const historyEntry = {      timestamp: new Date().toISOString(),      actionType,      oldScore,      newScore,      change: pointChange,      reason: reason || `${actionType} action`    };    userData.score = newScore;    userData.history.push(historyEntry);    if (userData.history.length > 100) {      userData.history = userData.history.slice(-100);    }    userData.lastUpdated = new Date().toISOString();    userData.trustLevel = newTrustLevel;    reputationStorage.update(key, userData);    if (oldTrustLevel !== newTrustLevel) {      await this.handleTrustLevelChange(userId, guildId, oldTrustLevel, newTrustLevel, userData);    }    if (pointChange < -5) {      await this.logSignificantChange(userId, guildId, historyEntry);    }    return userData;  }  getTrustLevel(score) {    if (score <= this.thresholds.danger) return 'danger';    if (score <= this.thresholds.warning) return 'warning';    if (score <= this.thresholds.suspicious) return 'suspicious';    if (score >= this.thresholds.moderationHelper) return 'moderationHelper';    if (score >= this.thresholds.respected) return 'respected';    if (score >= this.thresholds.trusted) return 'trusted';    return 'neutral';  }  getReputationEmoji(trustLevel) {    switch (trustLevel) {      case 'danger': return '⛔';      case 'warning': return '⚠️';      case 'suspicious': return '🔍';      case 'neutral': return '⚪';      case 'trusted': return '✅';      case 'respected': return '⭐';      case 'moderationHelper': return '🛡️';      default: return '⚪';    }  }  getReputationColor(trustLevel) {    switch (trustLevel) {      case 'danger': return '#ff0000';      case 'warning': return '#ffa500';      case 'suspicious': return '#ffff00';      case 'neutral': return '#cccccc';      case 'trusted': return '#00ff00';      case 'respected': return '#00ffff';      case 'moderationHelper': return '#0000ff';      default: return '#cccccc';    }  }  async handleTrustLevelChange(userId, guildId, oldLevel, newLevel, userData) {    if (!this.client || !this.client.config) return;    const securityChannelId = this.client.config.channels?.['security-logs'];    if (!securityChannelId) return;    try {      const channel = await this.client.channels.fetch(securityChannelId).catch(() => null);      if (!channel) return;      const user = await this.client.users.fetch(userId).catch(() => null);      const guild = await this.client.guilds.fetch(guildId).catch(() => null);      if (!user || !guild) return;      const embed = new EmbedBuilder()        .setTitle(`${this.getReputationEmoji(newLevel)} Kullanıcı Güven Seviyesi Değişti`)        .setDescription(`<@${userId}> kullanıcısının güven seviyesi değişti.`)        .setColor(this.getReputationColor(newLevel))        .addFields(          { name: 'Kullanıcı', value: `${user.tag} (${userId})`, inline: true },          { name: 'Sunucu', value: guild.name, inline: true },          { name: 'Eski Seviye', value: `${this.getReputationEmoji(oldLevel)} ${oldLevel.charAt(0).toUpperCase() + oldLevel.slice(1)}`, inline: true },          { name: 'Yeni Seviye', value: `${this.getReputationEmoji(newLevel)} ${newLevel.charAt(0).toUpperCase() + newLevel.slice(1)}`, inline: true },          { name: 'İtibar Puanı', value: userData.score.toFixed(2), inline: true },          { name: 'Son Değişiklik', value: userData.history[userData.history.length - 1]?.reason || 'Bilinmiyor', inline: true }        )        .setTimestamp()        .setFooter({ text: 'Kullanıcı İtibar Sistemi' });      if (user.displayAvatarURL()) {        embed.setThumbnail(user.displayAvatarURL({ dynamic: true }));      }      await channel.send({ embeds: [embed] });      if (newLevel === 'danger' || newLevel === 'warning') {        await this.applyAutomatedActions(userId, guildId, newLevel, userData);      }    } catch (error) {      console.error('Error handling trust level change:', error);    }  }  async applyAutomatedActions(userId, guildId, trustLevel, userData) {    if (!this.client.customLogs) return;    try {      const guild = await this.client.guilds.fetch(guildId).catch(() => null);      if (!guild) return;      const member = await guild.members.fetch(userId).catch(() => null);      if (!member) return;      if (trustLevel === 'danger') {        this.client.customLogs.logSecurity('lowReputationUser', userId, guildId, {          severity: 'ALERT',          content: `Tehlikeli seviyede düşük itibar puanına sahip kullanıcı tespit edildi: ${userData.score.toFixed(2)}`,          details: {            userId,            username: member.user.tag,            trustLevel,            score: userData.score,            recentActions: userData.history.slice(-5)          }        });        if (this.client.config.customLogs?.security?.autoModeration?.enabled) {          try {            await member.timeout(3 * 60 * 60 * 1000, 'Düşük itibar puanı - Otomatik eylem');            this.addUserWarning(userId, guildId, 'Sistem', 'Tehlikeli seviyede düşük itibar puanı');            this.client.customLogs.logSecurity('autoModAction', userId, guildId, {              severity: 'WARNING',              content: `Düşük itibar puanına sahip kullanıcıya otomatik zaman aşımı uygulandı`,              details: {                userId,                username: member.user.tag,                action: 'timeout',                duration: '3 hours',                reason: 'Düşük itibar puanı - Otomatik eylem'              }            });          } catch (error) {            console.error('Error applying timeout:', error);          }        }      } else if (trustLevel === 'warning') {        this.client.customLogs.logSecurity('lowReputationUser', userId, guildId, {          severity: 'WARNING',          content: `Düşük itibar puanına sahip kullanıcı tespit edildi: ${userData.score.toFixed(2)}`,          details: {            userId,            username: member.user.tag,            trustLevel,            score: userData.score,            recentActions: userData.history.slice(-5)          }        });        this.addUserTracking(userId, guildId);      }    } catch (error) {      console.error('Error applying automated actions:', error);    }  }  addUserTracking(userId, guildId) {    if (!this.client.logger) return false;    try {      this.client.logger.addUserTracker(userId, {        notifyChannel: 'security-logs',        reason: 'Düşük itibar puanı - Otomatik izleme',        trackMessages: true,        trackVoice: true,        trackMember: true      });      return true;    } catch (error) {      console.error('Error adding user tracking:', error);      return false;    }  }  async logSignificantChange(userId, guildId, historyEntry) {    if (!this.client.customLogs) return;    this.client.customLogs.logSecurity('reputationChange', userId, guildId, {      severity: 'NOTICE',      content: `Kullanıcı itibar puanında önemli değişiklik: ${historyEntry.change.toFixed(2)}`,      details: {        userId,        oldScore: historyEntry.oldScore,        newScore: historyEntry.newScore,        change: historyEntry.change,        actionType: historyEntry.actionType,        reason: historyEntry.reason      }    });  }  addUserWarning(userId, guildId, moderatorId, reason) {    const warningId = `warning_${Date.now()}_${Math.floor(Math.random() * 1000)}`;    const key = `${userId}-${guildId}`;    const warning = {      id: warningId,      userId,      guildId,      moderatorId,      reason,      timestamp: new Date().toISOString(),      active: true    };    warningStorage.add(warning);    this.updateReputation(userId, guildId, 'WARN_RECEIVE', null, `Warned by ${moderatorId}: ${reason}`);    return warningId;  }  getUserWarnings(userId, guildId, activeOnly = false) {    return warningStorage.find(warning =>       warning.userId === userId &&       warning.guildId === guildId &&      (!activeOnly || warning.active)    );  }  removeWarning(warningId) {    const warning = warningStorage.find(w => w.id === warningId)[0];    if (!warning) return false;    warning.active = false;    warningStorage.update(warning.id, warning);    this.updateReputation(      warning.userId,       warning.guildId,       'WARN_REMOVE',       1,       `Warning removed: ${warning.reason}`    );    return true;  }  async checkUserReputation(userId, guildId) {    const userData = this.getUserReputation(userId, guildId);    if (userData.score <= this.thresholds.suspicious) {      const guild = await this.client.guilds.fetch(guildId).catch(() => null);      if (!guild) return userData;      const member = await guild.members.fetch(userId).catch(() => null);      if (!member) return userData;      const trustLevel = this.getTrustLevel(userData.score);      const warningCount = this.getUserWarnings(userId, guildId, true).length;      this.client.customLogs.logSecurity('reputationCheck', userId, guildId, {        severity: userData.score <= this.thresholds.danger ? 'WARNING' : 'NOTICE',        content: `Düşük itibar puanlı kullanıcı etkinliği: ${userData.score.toFixed(2)}`,        details: {          userId,          username: member.user.tag,          trustLevel,          score: userData.score,          warningCount,          joinedAt: member.joinedAt,          accountCreated: member.user.createdAt        }      });    }    return userData;  }  getTopUsers(guildId, limit = 10) {    const guildUsers = reputationStorage.find(data => data.guildId === guildId);    return guildUsers      .sort((a, b) => b.score - a.score)      .slice(0, limit);  }  getBottomUsers(guildId, limit = 10) {    const guildUsers = reputationStorage.find(data => data.guildId === guildId);    return guildUsers      .sort((a, b) => a.score - b.score)      .slice(0, limit);  }  async createReputationEmbed(userId, guildId) {    const userData = this.getUserReputation(userId, guildId);    const user = await this.client.users.fetch(userId).catch(() => null);    const guild = await this.client.guilds.fetch(guildId).catch(() => null);    if (!user || !guild) return null;    const warnings = this.getUserWarnings(userId, guildId);    const activeWarnings = warnings.filter(w => w.active);    const trustLevel = this.getTrustLevel(userData.score);    const position = this.getPositionInServer(userId, guildId);    const recentHistory = userData.history      .slice(-5)      .reverse()      .map(entry => {        const date = new Date(entry.timestamp);        return `${date.toLocaleDateString()} - ${entry.reason} (${entry.change > 0 ? '+' : ''}${entry.change.toFixed(1)})`;      })      .join('\n');    const embed = new EmbedBuilder()      .setTitle(`${this.getReputationEmoji(trustLevel)} Kullanıcı İtibar Profili`)      .setDescription(`<@${userId}> kullanıcısının itibar bilgileri`)      .setColor(this.getReputationColor(trustLevel))      .addFields(        { name: 'Kullanıcı', value: `${user.tag} (${userId})`, inline: true },        { name: 'Sunucu', value: guild.name, inline: true },        { name: 'İtibar Puanı', value: userData.score.toFixed(2), inline: true },        { name: 'Güven Seviyesi', value: `${this.getReputationEmoji(trustLevel)} ${trustLevel.charAt(0).toUpperCase() + trustLevel.slice(1)}`, inline: true },        { name: 'Sunucu Sıralaması', value: `#${position}`, inline: true },        { name: 'Uyarılar', value: `${activeWarnings.length} aktif / ${warnings.length} toplam`, inline: true },        { name: 'İlk Görülme', value: `<t:${Math.floor(new Date(userData.firstSeen).getTime() / 1000)}:R>`, inline: true },        { name: 'Son Güncelleme', value: `<t:${Math.floor(new Date(userData.lastUpdated).getTime() / 1000)}:R>`, inline: true }      )      .setTimestamp()      .setFooter({ text: 'Kullanıcı İtibar Sistemi' });    if (recentHistory) {      embed.addFields({ name: 'Son Aktiviteler', value: recentHistory, inline: false });    }    if (user.displayAvatarURL()) {      embed.setThumbnail(user.displayAvatarURL({ dynamic: true }));    }    return embed;  }  getPositionInServer(userId, guildId) {    const guildUsers = reputationStorage.find(data => data.guildId === guildId);    const sortedUsers = guildUsers.sort((a, b) => b.score - a.score);    const position = sortedUsers.findIndex(user => user.userId === userId) + 1;    return position;  }}module.exports = UserReputation; 