const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionFlagsBits } = require('discord.js');module.exports = {  name: 'stats',  aliases: ['istatistik', 'stats', 'sunucu'],  description: 'Sunucu istatistiklerini ve log analitiklerini görüntüler',  usage: '.stats [genel/detay/mesaj/üye/ses]',  category: 'bilgi',  async execute(message, args, client) {    const startTime = Date.now();    if (!client.customLogs) {      return message.reply('Log sistemi henüz başlatılmamış.');    }    let subcommand = args[0] || 'genel';    try {      switch (subcommand.toLowerCase()) {        case 'detay':        case 'detailed':          return this.showDetailedStats(message, client);        case 'mesaj':        case 'messages':          return this.showMessageStats(message, client);        case 'üye':        case 'member':          return this.showMemberStats(message, client);        case 'ses':        case 'voice':          return this.showVoiceStats(message, client);        case 'genel':        case 'general':        default:          return this.showGeneralStats(message, client);      }    } catch (error) {      console.error('Error executing stats command:', error);      if (client.customLogs) {        client.customLogs.logError(error, 'stats command', message.author.id, message.guild.id);      }      return message.reply('İstatistikler görüntülenirken bir hata oluştu.');    } finally {      const processingTime = Date.now() - startTime;      if (client.customLogs) {        client.customLogs.logCommand(          'stats',          message.author.id,          message.guild.id,          true,          processingTime,          null        );      }    }  },  async showGeneralStats(message, client) {    try {      const guild = message.guild;      const generalStats = await this.collectGeneralStats(guild, client);      const lastDayStats = await this.collectLastDayStats(guild, client);      const embed = new EmbedBuilder()        .setTitle(`📊 ${guild.name} Sunucu İstatistikleri`)        .setDescription(`${guild.name} sunucusunun genel istatistik bilgileri`)        .setColor('#3498db')        .setTimestamp()        .setThumbnail(guild.iconURL({ dynamic: true }))        .addFields(          { name: '👥 Üye Sayısı', value: `**${generalStats.memberCount}** üye\n**${generalStats.botCount}** bot\n**${generalStats.onlineCount}** çevrimiçi`, inline: true },          { name: '📊 Sunucu Bilgileri', value: `**${generalStats.channelCount}** kanal\n**${generalStats.roleCount}** rol\n**${generalStats.emojiCount}** emoji`, inline: true },          { name: '📆 Oluşturulma Tarihi', value: `<t:${Math.floor(guild.createdTimestamp / 1000)}:F>`, inline: true },          { name: '📈 Son 24 Saat', value: `**${lastDayStats.totalLogs}** log kaydı\n**${lastDayStats.memberJoins}** yeni üye\n**${lastDayStats.messageCount}** mesaj`, inline: true },          { name: '🔊 Ses İstatistikleri', value: `**${lastDayStats.voiceJoins}** ses bağlantısı\n**${lastDayStats.voiceTime}** saat toplam ses`, inline: true },          { name: '🛡️ Güvenlik', value: `**${lastDayStats.securityAlerts}** güvenlik uyarısı\n**${lastDayStats.commandCount}** komut kullanımı`, inline: true }        )        .setFooter({ text: `Sunucu ID: ${guild.id} • İstek: ${message.author.tag}` });      const row = new ActionRowBuilder().addComponents(        new ButtonBuilder()          .setCustomId(`stats_detail_${message.author.id}`)          .setLabel('📊 Detaylı İstatistik')          .setStyle(ButtonStyle.Primary),        new ButtonBuilder()          .setCustomId(`stats_messages_${message.author.id}`)          .setLabel('💬 Mesaj İstatistikleri')          .setStyle(ButtonStyle.Secondary),        new ButtonBuilder()          .setCustomId(`stats_members_${message.author.id}`)          .setLabel('👥 Üye İstatistikleri')          .setStyle(ButtonStyle.Secondary),        new ButtonBuilder()          .setCustomId(`stats_voice_${message.author.id}`)          .setLabel('🔊 Ses İstatistikleri')          .setStyle(ButtonStyle.Secondary)      );      const reply = await message.reply({ embeds: [embed], components: [row] });      const filter = i => i.customId.startsWith('stats_') && i.customId.includes(message.author.id);      const collector = reply.createMessageComponentCollector({ filter, time: 300000 });      collector.on('collect', async (interaction) => {        await interaction.deferUpdate();        if (interaction.customId === `stats_detail_${message.author.id}`) {          const detailEmbed = await this.createDetailedStatsEmbed(guild, client);          await interaction.followUp({ embeds: [detailEmbed], ephemeral: true });        } else if (interaction.customId === `stats_messages_${message.author.id}`) {          const messageEmbed = await this.createMessageStatsEmbed(guild, client);          await interaction.followUp({ embeds: [messageEmbed], ephemeral: true });        } else if (interaction.customId === `stats_members_${message.author.id}`) {          const memberEmbed = await this.createMemberStatsEmbed(guild, client);          await interaction.followUp({ embeds: [memberEmbed], ephemeral: true });        } else if (interaction.customId === `stats_voice_${message.author.id}`) {          const voiceEmbed = await this.createVoiceStatsEmbed(guild, client);          await interaction.followUp({ embeds: [voiceEmbed], ephemeral: true });        }      });      collector.on('end', () => {        reply.edit({ components: [] }).catch(() => {});      });    } catch (error) {      console.error('Error showing general stats:', error);      return message.reply('İstatistikler görüntülenirken bir hata oluştu.');    }  },  async showDetailedStats(message, client) {    try {      const guild = message.guild;      const detailEmbed = await this.createDetailedStatsEmbed(guild, client);      return message.reply({ embeds: [detailEmbed] });    } catch (error) {      console.error('Error showing detailed stats:', error);      return message.reply('Detaylı istatistikler görüntülenirken bir hata oluştu.');    }  },  async showMessageStats(message, client) {    try {      const guild = message.guild;      const messageEmbed = await this.createMessageStatsEmbed(guild, client);      return message.reply({ embeds: [messageEmbed] });    } catch (error) {      console.error('Error showing message stats:', error);      return message.reply('Mesaj istatistikleri görüntülenirken bir hata oluştu.');    }  },  async showMemberStats(message, client) {    try {      const guild = message.guild;      const memberEmbed = await this.createMemberStatsEmbed(guild, client);      return message.reply({ embeds: [memberEmbed] });    } catch (error) {      console.error('Error showing member stats:', error);      return message.reply('Üye istatistikleri görüntülenirken bir hata oluştu.');    }  },  async showVoiceStats(message, client) {    try {      const guild = message.guild;      const voiceEmbed = await this.createVoiceStatsEmbed(guild, client);      return message.reply({ embeds: [voiceEmbed] });    } catch (error) {      console.error('Error showing voice stats:', error);      return message.reply('Ses istatistikleri görüntülenirken bir hata oluştu.');    }  },  async collectGeneralStats(guild, client) {    try {      const members = await guild.members.fetch();      const memberCount = members.filter(member => !member.user.bot).size;      const botCount = members.filter(member => member.user.bot).size;      const onlineCount = members.filter(member => member.presence?.status === 'online' || member.presence?.status === 'idle' || member.presence?.status === 'dnd').size;      const channelCount = guild.channels.cache.size;      const textChannelCount = guild.channels.cache.filter(c => c.type === 0).size;      const voiceChannelCount = guild.channels.cache.filter(c => c.type === 2).size;      const categoryCount = guild.channels.cache.filter(c => c.type === 4).size;      const roleCount = guild.roles.cache.size;      const emojiCount = guild.emojis.cache.size;      return {        memberCount,        botCount,        onlineCount,        channelCount,        textChannelCount,        voiceChannelCount,        categoryCount,        roleCount,        emojiCount      };    } catch (error) {      console.error('Error collecting general stats:', error);      return {        memberCount: 0,        botCount: 0,        onlineCount: 0,        channelCount: 0,        textChannelCount: 0,        voiceChannelCount: 0,        categoryCount: 0,        roleCount: 0,        emojiCount: 0      };    }  },  async collectLastDayStats(guild, client) {    try {      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);      const messageActivityLogs = await client.customLogs.getLogsByDateRange(        oneDayAgo,        new Date(),        'userActivity'      );      const securityLogs = await client.customLogs.getLogsByDateRange(        oneDayAgo,        new Date(),        'security'      );      const commandLogs = await client.customLogs.getLogsByDateRange(        oneDayAgo,        new Date(),        'command'      );      const messageCount = messageActivityLogs.filter(log =>         log.details?.action === 'messageCreate' &&         log.guildId === guild.id      ).length;      const memberJoins = messageActivityLogs.filter(log =>         log.details?.action === 'memberJoin' &&         log.guildId === guild.id      ).length;      const voiceJoins = messageActivityLogs.filter(log =>         log.details?.action === 'voiceJoin' &&         log.guildId === guild.id      ).length;      const voiceTimeLogs = messageActivityLogs.filter(log =>         log.details?.action === 'voiceSession' &&         log.guildId === guild.id &&        log.details?.duration      );      let totalVoiceTime = 0;      for (const log of voiceTimeLogs) {        totalVoiceTime += log.details.duration || 0;      }      const voiceTimeHours = Math.floor(totalVoiceTime / 1000 / 60 / 60);      const securityAlerts = securityLogs.filter(log =>         log.guildId === guild.id &&         (log.severity === 'WARNING' || log.severity === 'ALERT' || log.severity === 'CRITICAL')      ).length;      const commandCount = commandLogs.filter(log =>         log.guildId === guild.id      ).length;      const totalLogs = messageActivityLogs.filter(log =>         log.guildId === guild.id      ).length + securityLogs.filter(log =>         log.guildId === guild.id      ).length + commandLogs.filter(log =>         log.guildId === guild.id      ).length;      return {        messageCount,        memberJoins,        voiceJoins,        voiceTime: voiceTimeHours,        securityAlerts,        commandCount,        totalLogs      };    } catch (error) {      console.error('Error collecting last day stats:', error);      return {        messageCount: 0,        memberJoins: 0,        voiceJoins: 0,        voiceTime: 0,        securityAlerts: 0,        commandCount: 0,        totalLogs: 0      };    }  },  async createDetailedStatsEmbed(guild, client) {    try {      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);      const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);      const lastDayLogs = await client.customLogs.getLogsByDateRange(        oneDayAgo,        new Date()      );      const lastWeekLogs = await client.customLogs.getLogsByDateRange(        oneWeekAgo,        new Date()      );      const logTypes = {};      const logSeverity = {};      for (const log of lastWeekLogs) {        if (log.guildId === guild.id) {          logTypes[log.type] = (logTypes[log.type] || 0) + 1;          logSeverity[log.severity] = (logSeverity[log.severity] || 0) + 1;        }      }      const mostActiveHoursMap = {};      for (const log of lastDayLogs) {        if (log.guildId === guild.id) {          const hour = new Date(log.timestamp).getHours();          mostActiveHoursMap[hour] = (mostActiveHoursMap[hour] || 0) + 1;        }      }      const mostActiveHours = Object.entries(mostActiveHoursMap)        .sort((a, b) => b[1] - a[1])        .slice(0, 3)        .map(([hour, count]) => `${hour}:00 (${count} log)`);      const logTypeText = Object.entries(logTypes)        .sort((a, b) => b[1] - a[1])        .map(([type, count]) => `${type}: ${count}`)        .join('\n');      const severityEmojis = {        'DEBUG': '🔍',        'INFO': 'ℹ️',        'NOTICE': '📝',        'WARNING': '⚠️',        'ERROR': '❌',        'CRITICAL': '🔥',        'ALERT': '🚨',        'EMERGENCY': '☢️'      };      const logSeverityText = Object.entries(logSeverity)        .sort((a, b) => b[1] - a[1])        .map(([severity, count]) => `${severityEmojis[severity] || ''} ${severity}: ${count}`)        .join('\n');      const embed = new EmbedBuilder()        .setTitle(`📊 Detaylı Log İstatistikleri - ${guild.name}`)        .setDescription(`Son 7 gün içindeki log aktivitelerinin detaylı analizi`)        .setColor('#3498db')        .setTimestamp()        .setThumbnail(guild.iconURL({ dynamic: true }))        .addFields(          { name: '📝 Log Tipleri', value: logTypeText || 'Veri yok', inline: true },          { name: '🚨 Önem Seviyeleri', value: logSeverityText || 'Veri yok', inline: true },          { name: '⏰ En Aktif Saatler', value: mostActiveHours.join('\n') || 'Veri yok', inline: true }        )        .setFooter({ text: `Sunucu ID: ${guild.id} • İstek: ${new Date().toISOString()}` });      return embed;    } catch (error) {      console.error('Error creating detailed stats embed:', error);      const embed = new EmbedBuilder()        .setTitle(`📊 Detaylı Log İstatistikleri - ${guild.name}`)        .setDescription(`İstatistikler görüntülenirken bir hata oluştu.`)        .setColor('#e74c3c')        .setTimestamp();      return embed;    }  },  async createMessageStatsEmbed(guild, client) {    try {      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);      const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);      const messageActivityLogs = await client.customLogs.getLogsByDateRange(        oneWeekAgo,        new Date(),        'userActivity'      );      const messageLogs = messageActivityLogs.filter(log =>         log.details?.action === 'messageCreate' &&         log.guildId === guild.id      );      const userMessageCounts = {};      const channelMessageCounts = {};      for (const log of messageLogs) {        userMessageCounts[log.userId] = (userMessageCounts[log.userId] || 0) + 1;        if (log.details?.channelId) {          channelMessageCounts[log.details.channelId] = (channelMessageCounts[log.details.channelId] || 0) + 1;        }      }      const topUsers = Object.entries(userMessageCounts)        .sort((a, b) => b[1] - a[1])        .slice(0, 5);      const topChannels = Object.entries(channelMessageCounts)        .sort((a, b) => b[1] - a[1])        .slice(0, 5);      let topUsersText = '';      for (const [userId, count] of topUsers) {        const user = await client.users.fetch(userId).catch(() => null);        topUsersText += `${user ? user.tag : userId}: ${count} mesaj\n`;      }      let topChannelsText = '';      for (const [channelId, count] of topChannels) {        topChannelsText += `<#${channelId}>: ${count} mesaj\n`;      }      const hourlyActivity = Array(24).fill(0);      for (const log of messageLogs) {        const hour = new Date(log.timestamp).getHours();        hourlyActivity[hour]++;      }      const mostActiveHour = hourlyActivity.indexOf(Math.max(...hourlyActivity));      const leastActiveHour = hourlyActivity.indexOf(Math.min(...hourlyActivity));      const dailyActivity = Array(7).fill(0);      for (const log of messageLogs) {        const date = new Date(log.timestamp);        const dayIndex = 6 - Math.floor((Date.now() - date.getTime()) / (24 * 60 * 60 * 1000));        if (dayIndex >= 0 && dayIndex < 7) {          dailyActivity[dayIndex]++;        }      }      const weekdays = ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'];      const today = new Date().getDay();      const daysText = Array(7).fill().map((_, i) => {        const dayIndex = (today - 6 + i + 7) % 7;        return `${weekdays[dayIndex]}: ${dailyActivity[i]} mesaj`;      }).join('\n');      const embed = new EmbedBuilder()        .setTitle(`💬 Mesaj İstatistikleri - ${guild.name}`)        .setDescription(`Son 7 gün içinde toplam **${messageLogs.length}** mesaj gönderildi.`)        .setColor('#2ecc71')        .setTimestamp()        .setThumbnail(guild.iconURL({ dynamic: true }))        .addFields(          { name: '👥 En Aktif Kullanıcılar', value: topUsersText || 'Veri yok', inline: true },          { name: '📢 En Aktif Kanallar', value: topChannelsText || 'Veri yok', inline: true },          { name: '⏰ Aktivite', value: `En aktif saat: **${mostActiveHour}:00**\nEn sakin saat: **${leastActiveHour}:00**\n\n**Günlük Aktivite:**\n${daysText}`, inline: false }        )        .setFooter({ text: `Toplam mesaj sayısı: ${messageLogs.length} • Son 7 gün` });      return embed;    } catch (error) {      console.error('Error creating message stats embed:', error);      const embed = new EmbedBuilder()        .setTitle(`💬 Mesaj İstatistikleri - ${guild.name}`)        .setDescription(`İstatistikler görüntülenirken bir hata oluştu.`)        .setColor('#e74c3c')        .setTimestamp();      return embed;    }  },  async createMemberStatsEmbed(guild, client) {    try {      const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);      const memberActivityLogs = await client.customLogs.getLogsByDateRange(        oneWeekAgo,        new Date(),        'userActivity'      );      const joinLogs = memberActivityLogs.filter(log =>         log.details?.action === 'memberJoin' &&         log.guildId === guild.id      );      const leaveLogs = memberActivityLogs.filter(log =>         log.details?.action === 'memberLeave' &&         log.guildId === guild.id      );      const dailyJoins = Array(7).fill(0);      const dailyLeaves = Array(7).fill(0);      for (const log of joinLogs) {        const date = new Date(log.timestamp);        const dayIndex = 6 - Math.floor((Date.now() - date.getTime()) / (24 * 60 * 60 * 1000));        if (dayIndex >= 0 && dayIndex < 7) {          dailyJoins[dayIndex]++;        }      }      for (const log of leaveLogs) {        const date = new Date(log.timestamp);        const dayIndex = 6 - Math.floor((Date.now() - date.getTime()) / (24 * 60 * 60 * 1000));        if (dayIndex >= 0 && dayIndex < 7) {          dailyLeaves[dayIndex]++;        }      }      const weekdays = ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'];      const today = new Date().getDay();      const memberTrendText = Array(7).fill().map((_, i) => {        const dayIndex = (today - 6 + i + 7) % 7;        return `${weekdays[dayIndex]}: +${dailyJoins[i]} / -${dailyLeaves[i]} (${dailyJoins[i] - dailyLeaves[i] >= 0 ? '+' : ''}${dailyJoins[i] - dailyLeaves[i]})`;      }).join('\n');      const members = await guild.members.fetch();      const totalMembers = members.filter(member => !member.user.bot).size;      const totalBots = members.filter(member => member.user.bot).size;      const onlineMembers = members.filter(member => member.presence?.status === 'online').size;      const idleMembers = members.filter(member => member.presence?.status === 'idle').size;      const dndMembers = members.filter(member => member.presence?.status === 'dnd').size;      const offlineMembers = members.filter(member => !member.presence || member.presence.status === 'offline').size;      const rolesMap = {};      members.forEach(member => {        member.roles.cache.forEach(role => {          if (role.id !== guild.id) {             rolesMap[role.id] = {              name: role.name,              count: (rolesMap[role.id]?.count || 0) + 1            };          }        });      });      const topRoles = Object.entries(rolesMap)        .sort((a, b) => b[1].count - a[1].count)        .slice(0, 5)        .map(([id, { name, count }]) => `<@&${id}>: ${count} üye`)        .join('\n');      const embed = new EmbedBuilder()        .setTitle(`👥 Üye İstatistikleri - ${guild.name}`)        .setDescription(`Sunucuda toplam **${totalMembers}** üye ve **${totalBots}** bot bulunuyor.`)        .setColor('#9b59b6')        .setTimestamp()        .setThumbnail(guild.iconURL({ dynamic: true }))        .addFields(          { name: '📊 Üye Durumları', value: `🟢 Çevrimiçi: ${onlineMembers}\n🟡 Boşta: ${idleMembers}\n🔴 Rahatsız Etmeyin: ${dndMembers}\n⚫ Çevrimdışı: ${offlineMembers}`, inline: true },          { name: '👑 En Popüler Roller', value: topRoles || 'Veri yok', inline: true },          { name: '📈 Üye Trendi (Son 7 Gün)', value: memberTrendText || 'Veri yok', inline: false }        )        .setFooter({ text: `Son 7 günde: ${joinLogs.length} yeni üye, ${leaveLogs.length} ayrılan üye` });      return embed;    } catch (error) {      console.error('Error creating member stats embed:', error);      const embed = new EmbedBuilder()        .setTitle(`👥 Üye İstatistikleri - ${guild.name}`)        .setDescription(`İstatistikler görüntülenirken bir hata oluştu.`)        .setColor('#e74c3c')        .setTimestamp();      return embed;    }  },  async createVoiceStatsEmbed(guild, client) {    try {      const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);      const voiceActivityLogs = await client.customLogs.getLogsByDateRange(        oneWeekAgo,        new Date(),        'userActivity'      );      const voiceJoinLogs = voiceActivityLogs.filter(log =>         log.details?.action === 'voiceJoin' &&         log.guildId === guild.id      );      const voiceSessionLogs = voiceActivityLogs.filter(log =>         log.details?.action === 'voiceSession' &&         log.guildId === guild.id &&        log.details?.duration      );      const userVoiceTime = {};      const channelVoiceTime = {};      for (const log of voiceSessionLogs) {        const duration = log.details.duration || 0;        userVoiceTime[log.userId] = (userVoiceTime[log.userId] || 0) + duration;        if (log.details.channelId) {          channelVoiceTime[log.details.channelId] = (channelVoiceTime[log.details.channelId] || 0) + duration;        }      }      const topUsers = Object.entries(userVoiceTime)        .sort((a, b) => b[1] - a[1])        .slice(0, 5);      let topUsersText = '';      for (const [userId, duration] of topUsers) {        const user = await client.users.fetch(userId).catch(() => null);        const hours = Math.floor(duration / 1000 / 60 / 60);        const minutes = Math.floor((duration / 1000 / 60) % 60);        topUsersText += `${user ? user.tag : userId}: ${hours}s ${minutes}dk\n`;      }      const topChannels = Object.entries(channelVoiceTime)        .sort((a, b) => b[1] - a[1])        .slice(0, 5);      let topChannelsText = '';      for (const [channelId, duration] of topChannels) {        const hours = Math.floor(duration / 1000 / 60 / 60);        const minutes = Math.floor((duration / 1000 / 60) % 60);        topChannelsText += `<#${channelId}>: ${hours}s ${minutes}dk\n`;      }      const dailyVoiceActivity = Array(7).fill(0);      for (const log of voiceJoinLogs) {        const date = new Date(log.timestamp);        const dayIndex = 6 - Math.floor((Date.now() - date.getTime()) / (24 * 60 * 60 * 1000));        if (dayIndex >= 0 && dayIndex < 7) {          dailyVoiceActivity[dayIndex]++;        }      }      const weekdays = ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'];      const today = new Date().getDay();      const daysText = Array(7).fill().map((_, i) => {        const dayIndex = (today - 6 + i + 7) % 7;        return `${weekdays[dayIndex]}: ${dailyVoiceActivity[i]} ses bağlantısı`;      }).join('\n');      let totalVoiceTime = 0;      for (const duration of Object.values(userVoiceTime)) {        totalVoiceTime += duration;      }      const totalHours = Math.floor(totalVoiceTime / 1000 / 60 / 60);      const totalMinutes = Math.floor((totalVoiceTime / 1000 / 60) % 60);      const voiceChannels = guild.channels.cache.filter(channel => channel.type === 2);      let currentVoiceUsers = 0;      voiceChannels.forEach(channel => {        currentVoiceUsers += channel.members.size;      });      const embed = new EmbedBuilder()        .setTitle(`🔊 Ses İstatistikleri - ${guild.name}`)        .setDescription(`Son 7 gün içinde toplam **${totalHours} saat ${totalMinutes} dakika** ses kanalı kullanımı gerçekleşti.`)        .setColor('#f1c40f')        .setTimestamp()        .setThumbnail(guild.iconURL({ dynamic: true }))        .addFields(          { name: '👥 En Aktif Kullanıcılar', value: topUsersText || 'Veri yok', inline: true },          { name: '📢 En Aktif Kanallar', value: topChannelsText || 'Veri yok', inline: true },          { name: '📈 Günlük Aktivite', value: daysText || 'Veri yok', inline: false },          { name: '📊 Genel Durum', value: `**${currentVoiceUsers}** kullanıcı şu anda ses kanallarında\n**${voiceJoinLogs.length}** toplam ses kanalı bağlantısı`, inline: false }        )        .setFooter({ text: `Toplam ses süresi: ${totalHours} saat ${totalMinutes} dakika • Son 7 gün` });      return embed;    } catch (error) {      console.error('Error creating voice stats embed:', error);      const embed = new EmbedBuilder()        .setTitle(`🔊 Ses İstatistikleri - ${guild.name}`)        .setDescription(`İstatistikler görüntülenirken bir hata oluştu.`)        .setColor('#e74c3c')        .setTimestamp();      return embed;    }  }}; 